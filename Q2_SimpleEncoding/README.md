# Simple Encoding  
* 간단한 수학을 이용하여 영리한 코딩을 하는 문제  
* N개의 숫자를 입력받아 다른 하나의 숫자로 출력

## [문제의 이해]  
1. N개의 숫자 중에 하나를 선택  
1. 그 값을 1 증가시킴  
1. 모든 숫자를 곱함  
1. 곱 중에서 최대값을 선택하여 출력  

## [예시]  
Input이 1, 2, 3이면 출력 가능한 경우는  
**2\*2\*3(=12), 1\*3\*3(=9), 1\*2\*4(=8)**  
이 중 최대값이 12이므로 출력은 12가 되어야 함.  

### ◼️ **Hint**  
두 가지 방법이 있다.  

* **방법1) 전체 경우를 고려**  
과연 효율적일지?  
![simpleEncoding](https://user-images.githubusercontent.com/50273050/64916819-f411a300-d7c0-11e9-8d33-8390bf8d4f8e.jpg)  
가능한 모든 경우의 수를 계산하기 때문에 효율성이 떨어짐  

* **방법2) 간단한 산수를 통해 증가율을 고려**  
숫자 3개 a, b, c 중 하나를 골라 1 증가 시킨 후의 곱은  
(a+1)\*b\*c => 1/a  
a\*(b+1)\*c => 1/b  
a\*b\*(c+1) => 1/c  
따라서 증가율은 항상 **_(n+1)/n_** 의 형태이며  
가장 크게 증가시키려면 a, b, c 중 가장 작은 값을 증가시켜야 한다.  

### ◼️ **Warning**  
만약 array에 있는 숫자 자체를 증가시켜 곱셈을 진행했을 경우, 다시 숫자를 돌려놓아야 한다.  

### ◼️ **Solution**  
1. main) for문을 array의 길이만큼 돌려 숫자를 입력받는다.  
1. main) getEncodedNumber 함수를 호출한다.  
1. getEncodedNumber) 곱을 계산할 변수와 가장 작은 수의 index를 담을 변수를 선언한다.  
1. getEncodedNumber) for문으로 array의 길이만큼 반복하여 가장 작은 수를 찾는다.  
1. getEncodedNumber) 가장 작은 수를 1 증가시키고 전체 수를 곱한 후, 다시 작은 수를 1 감소 시킨다.  
1. getEncodedNumber) 전체 수를 곱한 수를 return 시킨다.  

* 시간복잡도  
가장 작은 수를 찾을 때의 방법에 따라 다르다.  
1) array 정렬 후에 arr[0]을 1 증가 => O(nlogn)  
**2) 단순히 for loop로 찾아낸 후에 1 증가 => O(n)**  

* 풀이 소요시간  
약 30분  

* 참고  
**현재 source code는 n(array의 크기)을 3으로 지정해놓은 상태.  
추후에 n을 입력받은 후 array를 입력받는 형식으로 바꿀 것.**  
