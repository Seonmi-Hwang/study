# Handshaking  
* 원탁에서 팔이 겹치지 않게 모두 악수를 하는 방법의 수를 구하는 문제  
* N개의 숫자(인원 수)를 입력받아 경우의 수를 리턴  

## [문제의 이해]  
1. 인원 수를 입력  
1. N = 2k일 때, H(2k) = H(2k-2) + H(2) \* H(2k-4) + H(3) \* H(2k-6) + ... + H(2k-4) \* H(2) + H(2k-2) 적용  
1. H(2k) 구하여 반환    

## [예시]  
N = 2 일 때, H(2) = 1  
N = 4 일 때, H(4) = 2  
N = 6 일 때, H(6) = 5  

Input) 6 [Enter]  
Output) 5  

### ◼️ **Hint**  
두 가지 방법이 있다.  

* **방법1) 전체 경우를 고려**  
문제의 이해 2번에서 나온 식을 좀 더 보기 쉽게 바꿔보자.   
**H(2k) = H(1) \* H(2k-2) + H(2) \* H(2k-4) + H(3) \* H(2k-6) + ... + H(2k-4) \* H(2) + H(2k-2) \* H(1)**  
위 공식에 따라 코딩을 하면 아래와 같다.  
```java
public static long getHandShaking(int n) { 
	int k = n / 2;  
		
	if (n == 0 || n == 2) return 1;  

	long count = 0;  
	for (int i = 0; i < k; i++) {  
		count += getHandShaking(2 * i) * getHandShaking(2 * (k - 1 - i));  
	}  
	return count;  
} 
```  
사실 H(0)은 없으나, 재귀 호출 시 종료조건(base condition)을 위해 H(0)을 1로 만들면 규칙이 성립된다.  
count는 k가 커졌을 때, 정수형 범위를 벗어날 수 있기 때문에 long타입으로 한다.  
반복문으로 k번 만큼 loop를 돌면, count에 쌓이게 되고 loop 탈출 후 반환한다.  
### BUT!  
N = 30 일 때부터 눈에 띄게 느려지더니, N = 40 일 때는 약 7초가 소요되었다.  
=> 속도를 높이려면 어떻게 해야할까? -> **방법2 이용!**  

* **방법2) Memoization 사용**  
Memoization을 이용하여 불필요한 재귀 호출을 줄여서  
k가 충분히 크더라도 1초에 계산할 수 있도록 한다.  

### ◼️ **Warning**  
K가 충분히 크더라도 1초에 계산을 할 수 있는 방법을 생각해보자.    

### ◼️ **Solution** 
\-

* 시간복잡도  
\-

* 풀이 소요시간  
\-
